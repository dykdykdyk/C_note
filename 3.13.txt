对于函数 array数组作为参数的时候，第一维可以不定义，但是第二维必须指定
int max_value(int array[][4])

变量
  在主函数中定义的变量也只在本函数中有效。
  在C语言程序设计中，一般讲全局变量的第一个字母大写。
  一般建议不适用全局变量
      1.全局变量在程序执行过程中都占用存储单元。
 当在全局变量和函数中定义了同命名的变量时，在函数内，局部变量会自动屏蔽全局变量。
静态存储方式是指在程序运行期间由系统分配固定的存储空间的方式，而动态存储方式则是在
程序运行期间根据需要进行动态的分配存储空间的方式。
  局部变量的存储类型
    1.自动变量(auto变量)
      函数的形参和在函数中定义的局部变量
    2.静态局部变量
      函数内用static声明的变量
      每次调用完成之后，它并不释放，静态局部变量是在编译时赋初值的，以后每次挑用函数时
不再重新赋初值而是只保留上次函数调用时结束的值
    3.寄存器变量(register变量)  一般函数内定义
      一般变量的值都是存放在内存中，需要存数的时候，由运算器送到内存存放，而如果有些变量使用
很频繁，，允许将局部变量的值存放在CPU中的寄存器中，需要用的时候直接从寄存器取出，这样可以提高运行效率
    register int f;
  全局变量的存储类型(全部都是存放在静态存储区的)
     1.在一个文件内扩展外部变量的作用域
         main{
	   extern int A,B,C;//把外部变量A,B,C的作用域扩展到从此处开始 还可以extern A,B,C;
	}
  	int A,B,C;	
      2.将外部变量的作用域扩展到其他文件(见Files demo)
	
      3.将外部变量的作用域限制在本文件中
        在定义外部变量前加static就可以了。这时就只能在本文件使用此变量	
 	注意：对局部变量用static声明，把他分配在静态储存区，在程序执行期间不释放。
	      对全局变量同static声明，则该变量的作用域只限于本文件模块
   声明和定义
       把建立存储空间的声明称定义，把不需要建立存储空间的声明称为声明       
   函数
     内部函数：只能被本文件中的其他函数所调用，称为内部函数。
     static int fun(int a)
     外部函数：在函数首部的最左端加关键字 extern,则侧函数是外部函数。
     extern int fun(int c)

指针
    指针的概念
        在程序定义一个变量，在编译时，系统会给这个变量分配内存单元，内存区中的
每一个字节有一个编号，这就是"地址"，这个地址指向该变量单元，因此，将地址形象
化地称为指针。
    直接访问 k=i+j;
    间接访问 int i_pointer =&i; //将i的地址存放到i_pointer中，i_pointer的值就是
变量i所占用单元的起始地址
    一个变量的地址称为该变量的"指针".地址2000是变量i的指针。
   如果有一个变量专门用来存放另一个变量的地址(即指针)，称它为"指针变量"。
指针变量就是地址变量。指针是一个地址，而指针变量是存放地址的变量。
   指针变量
    int a=100; 
    int *pointer_1; //定义指向整形数据的指针变量pointer_1
    pointer_1 =&a; //把变量a的地址赋给指针变量pointer_1  
    printf("*pointer_1=%d/n",*pointer_1); //输出的是a的值
    printf("pointer_1 =%d/n",pointer_1); //输出的是地址
     int *pointer_1;里面 *表示的是定义一个指针变量
     *pointer_1表示的是指针变量pointer_1所 指向 的变量，也就是变量a
   指针变量是基本数据类型派生出来的类型，他不能离开基本类型而单独存在.必须要
指定基类型，才能按存储单元的长度以及数据的存储形式正确地取出该数据。
     float *pointer_3;  char *pointer_4;
   point:整形数据占4字节，字符型数据占1字节，short型数据占2字节。
   一个变量的指针的含义包括两个方面，一是以存储单元编号表示的地址(如编号为2000
的字节)，一是它指向的存储单元的数据类型(如 int,char，float).
   2.引用指针变量
      1.给指针变量赋值
          p=&a;//指针变量p的值是变量a的地址，p指向a. 
      2.引用指针变量指向的变量
          p=&a; 
          printf("%d",*p);//输出变量a的值
          *p =1;     //表示将整数1赋给p当前所指向的变量，如果p指向变量a,相当
于把1赋给a,即 "a =1;"
          printf("%o",p);以八进制数形式输出指针变量p的值，如果p指向了a,
就是输出了a的地址。
          & 取地址运算符   * 指针运算符
       3.指针变量作为函数参数
           注意：  int *temp;   *temp =*p1;   这种语句有问题，因为未给temp
赋值，因此temp并无确定的值（不可预见），所以temp所指向的单元也是不可预见的。
 在调用指针函数的时候必须是指针所指向的变量的值发生了改变，在函数调用结束后
 ，这些变量值的变化依然保留下来。
  3.通过指针引用数组
      1.数组元素的指针
          int a[10] ={1,3,4,3};
          int *p;
	  p=&a[0]  ;//把a[0]元素的地址赋给指针变量p
      在C语言中，数组名(不包括形参数组名，形参数组并不占据实际的内存单元)代表数组中首
元素(即序号为0的元素)的地址，下面语句等价：p=&a[0];  p=a; //p的值是数组a首元素(即a[0]
的地址)  int *p =a;//作用是将a数组首元素(即a[0])的地址赋给指针变量p(而不是赋给 *p).
      2.引用数组元素时指针的运算
  	  在指针指向数组元素时，可以对指针进行以下运算.+  - 运算
	 如果指针变量p已指向数组中的一个元素，则 p+1指向同一个数组中的下一个元素， 
p-1指向同一个数组中的上一个元素，执行p+1并不是讲p的值简单加，而是加上一个数组元素所占用
的字节数。如float,每个元素占4个字节，则p+1意味着时p的值(地址)加4个字节（vc++6.0 int,
float,long，都是4字节 char 一个字节）同一个数组中两个元素相减，得到的是两个数组元素
之间的差值，即可以知道他们所指元素的相对距离。
       3.通过指针引用数组元素
	  *（a+1）或*(p+1)
          &a[i]表示a[i]元素的地址，也可以用(a+i)表示
          int *p,a[10],p=a;p++,表示将p的指针指向a[1].此时p的值表示的是a[1]的值。
	切记，在使用指针变量的时候，不要超过数组的越界，编译系统依然不会报错，但很难检查到
          如果指针变量指向一个数组时，可以带下标p[i],系统会处理成*(p+i),如果p是指向一个整
型数组元素a[0].则p[i]代表a[i].如果当前p指向a[3],则p[2]代表a[3+2],即a[5].
      	 ++(*p)得到a[0],*(++p)得到a[1]的值，*(p--)先对p进行"*"运算(求p所指向的元素的值，再
使p自减)。
	C语言，同等级运算时，从右向左
	4.数组名做函数参数
	  形参数组名是用来接收从实参传递过来的数组首元素地址的，因此，形参应该是一个指针变量
(只有指针才能存放地址)
	

       




    
     
      